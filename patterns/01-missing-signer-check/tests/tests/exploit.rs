/// # Pattern 1: Missing Signer Check — Mollusk Exploit Tests
///
/// These tests demonstrate the vulnerability using Mollusk (Anza's lightweight SVM test harness).
///
/// - Test 1: Proves the EXPLOIT — calling `withdraw_vulnerable` without the authority's
///   signature succeeds, allowing anyone to drain the vault.
/// - Test 2: Proves the FIX — calling `withdraw_secure` without the authority's signature
///   is rejected by Anchor's `Signer` constraint.
use mollusk_svm::{result::Check, Mollusk};
use sha2::{Digest, Sha256};
use solana_sdk::{
    account::AccountSharedData,
    instruction::{AccountMeta, Instruction},
    program_error::ProgramError,
    pubkey::Pubkey,
};

/// The program ID must match what's in declare_id!() in the Anchor program.
const PROGRAM_ID: Pubkey = solana_sdk::pubkey!("HF33f3iZYeK7qz7AE1aWWGvQuxArTudNjKVseAhTYCRC");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/// Compute an Anchor instruction discriminator: sha256("global:{name}")[..8]
fn ix_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("global:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

/// Compute an Anchor account discriminator: sha256("account:{name}")[..8]
fn account_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("account:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

/// Serialize a Vault account the way Anchor stores it on-chain:
///   [8-byte discriminator][32-byte authority pubkey][8-byte balance (LE)]
fn serialize_vault(authority: &Pubkey, balance: u64) -> Vec<u8> {
    let disc = account_discriminator("Vault");
    let mut data = Vec::with_capacity(48);
    data.extend_from_slice(&disc);
    data.extend_from_slice(authority.as_ref());
    data.extend_from_slice(&balance.to_le_bytes());
    data
}

/// Build a withdraw instruction with the given discriminator and amount.
fn build_withdraw_ix(
    disc_name: &str,
    vault: Pubkey,
    authority: Pubkey,
    recipient: Pubkey,
    authority_is_signer: bool,
    amount: u64,
) -> Instruction {
    let disc = ix_discriminator(disc_name);
    let mut data = Vec::with_capacity(16);
    data.extend_from_slice(&disc);
    data.extend_from_slice(&amount.to_le_bytes()); // borsh-encoded u64

    Instruction::new_with_bytes(
        PROGRAM_ID,
        &data,
        vec![
            AccountMeta::new(vault, false),                         // vault (writable, never signer)
            AccountMeta::new_readonly(authority, authority_is_signer), // authority
            AccountMeta::new(recipient, false),                     // recipient (writable)
        ],
    )
}

/// Create the set of accounts needed for a withdraw test.
///
/// Returns (vault_pda, authority, recipient, accounts_vec).
fn setup_withdraw_accounts(
    vault_balance_lamports: u64,
    vault_tracked_balance: u64,
) -> (Pubkey, Pubkey, Pubkey, Vec<(Pubkey, AccountSharedData)>) {
    let authority = Pubkey::new_unique();

    // Derive the vault PDA — same seeds as the Anchor program
    let (vault_pda, _bump) =
        Pubkey::find_program_address(&[b"vault", authority.as_ref()], &PROGRAM_ID);

    let recipient = Pubkey::new_unique();

    // Build the vault account as Anchor would store it
    let vault_data = serialize_vault(&authority, vault_tracked_balance);
    let mut vault_account = AccountSharedData::new(vault_balance_lamports, vault_data.len(), &PROGRAM_ID);
    vault_account.set_data_from_slice(&vault_data);

    // Authority account — needs some lamports to exist
    let authority_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    // Recipient account
    let recipient_account = AccountSharedData::new(0, 0, &solana_sdk::system_program::ID);

    let accounts = vec![
        (vault_pda, vault_account),
        (authority, authority_account),
        (recipient, recipient_account),
    ];

    (vault_pda, authority, recipient, accounts)
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[test]
fn exploit_withdraw_without_signer() {
    // -----------------------------------------------------------------------
    // EXPLOIT: Call withdraw_vulnerable where the authority does NOT sign.
    //
    // Expected: Transaction SUCCEEDS — this is the vulnerability.
    //
    // An attacker only needs to know the victim's public key. They pass it
    // as the authority without signing, and the funds are drained because
    // Anchor's `AccountInfo` type does not verify signatures.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "missing_signer");

    let withdraw_amount: u64 = 500_000;
    let vault_lamports: u64 = 1_000_000;

    let (vault_pda, authority, recipient, accounts) =
        setup_withdraw_accounts(vault_lamports, withdraw_amount);

    let ix = build_withdraw_ix(
        "withdraw_vulnerable",
        vault_pda,
        authority,
        recipient,
        false, // authority does NOT sign — this is the attack
        withdraw_amount,
    );

    // The exploit should succeed — that's the whole point of the vulnerability.
    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}

#[test]
fn secure_rejects_unsigned_withdraw() {
    // -----------------------------------------------------------------------
    // SECURE: Call withdraw_secure where the authority does NOT sign.
    //
    // Expected: Transaction FAILS — the Signer constraint blocks it.
    //
    // Anchor's `Signer<'info>` type checks `account.is_signer` during
    // deserialization. When it's false, Anchor returns error code 2002
    // (ConstraintSigner) wrapped as ProgramError::Custom(2002).
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "missing_signer");

    let withdraw_amount: u64 = 500_000;
    let vault_lamports: u64 = 1_000_000;

    let (vault_pda, authority, recipient, accounts) =
        setup_withdraw_accounts(vault_lamports, withdraw_amount);

    let ix = build_withdraw_ix(
        "withdraw_secure",
        vault_pda,
        authority,
        recipient,
        false, // authority does NOT sign — same attack, different instruction
        withdraw_amount,
    );

    // Anchor's Signer<'info> type checks is_signer during account deserialization.
    // When it fails, Anchor returns error code 3010 (AccountNotSigner)
    // which maps to ProgramError::Custom(3010).
    mollusk.process_and_validate_instruction(
        &ix,
        &accounts,
        &[Check::err(ProgramError::Custom(3010))],
    );
}

#[test]
fn secure_allows_signed_withdraw() {
    // -----------------------------------------------------------------------
    // SANITY CHECK: The secure instruction works when authority DOES sign.
    //
    // This proves the fix isn't a blanket denial — it correctly allows the
    // real authority to withdraw.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "missing_signer");

    let withdraw_amount: u64 = 500_000;
    let vault_lamports: u64 = 1_000_000;

    let (vault_pda, authority, recipient, accounts) =
        setup_withdraw_accounts(vault_lamports, withdraw_amount);

    let ix = build_withdraw_ix(
        "withdraw_secure",
        vault_pda,
        authority,
        recipient,
        true, // authority DOES sign — legitimate withdrawal
        withdraw_amount,
    );

    // Legitimate withdrawal should succeed.
    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}
