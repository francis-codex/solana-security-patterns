/// # Pattern 6: Type Cosplay (Account Confusion) — Mollusk Exploit Tests
///
/// Demonstrates how passing an account of the wrong type (but with the same
/// binary layout) can bypass authorization when the discriminator is unchecked.
///
/// - Test 1: EXPLOIT — vulnerable instruction accepts a UserData account
///   masquerading as AdminConfig (no discriminator check).
/// - Test 2: SECURE — instruction uses Account<AdminConfig> which auto-checks
///   the discriminator, rejecting the UserData cosplay.
/// - Test 3: SANITY — real AdminConfig works with the secure instruction.
use mollusk_svm::{result::Check, Mollusk};
use sha2::{Digest, Sha256};
use solana_sdk::{
    account::AccountSharedData,
    instruction::{AccountMeta, Instruction},
    program_error::ProgramError,
    pubkey::Pubkey,
};

const PROGRAM_ID: Pubkey = solana_sdk::pubkey!("HS241bzcteDvCTi6UMEfecj3o8JieRvZVL3F1zhZGPxP");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn ix_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("global:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

fn account_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("account:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

/// Serialize an AdminConfig:
///   [8-byte discriminator][32-byte admin][8-byte fee_basis_points]
fn serialize_admin_config(admin: &Pubkey, fee: u64) -> Vec<u8> {
    let disc = account_discriminator("AdminConfig");
    let mut data = Vec::with_capacity(48);
    data.extend_from_slice(&disc);
    data.extend_from_slice(admin.as_ref());
    data.extend_from_slice(&fee.to_le_bytes());
    data
}

/// Serialize a UserData:
///   [8-byte discriminator][32-byte authority][8-byte balance]
///
/// NOTE: Identical layout to AdminConfig, but DIFFERENT discriminator.
fn serialize_user_data(authority: &Pubkey, balance: u64) -> Vec<u8> {
    let disc = account_discriminator("UserData");
    let mut data = Vec::with_capacity(48);
    data.extend_from_slice(&disc);
    data.extend_from_slice(authority.as_ref());
    data.extend_from_slice(&balance.to_le_bytes());
    data
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[test]
fn exploit_type_cosplay_accepted() {
    // -----------------------------------------------------------------------
    // EXPLOIT: The vulnerable instruction uses UncheckedAccount and reads
    // the "admin" Pubkey at offset 8 WITHOUT checking the discriminator.
    //
    // We create a UserData account with the attacker's key as `authority`.
    // When passed to update_fee_vulnerable, the program reads the attacker's
    // key at offset 8 and treats it as the admin — the auth check passes!
    //
    // Result: Attacker modifies fees without being the real admin.
    //
    // Expected: SUCCEEDS — type cosplay bypasses authorization.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "type_cosplay");

    let attacker = Pubkey::new_unique();
    let fake_config = Pubkey::new_unique();

    // Create a UserData account (WRONG type!) with attacker as authority
    let user_data = serialize_user_data(&attacker, 0);
    let mut config_account =
        AccountSharedData::new(5_000_000, user_data.len(), &PROGRAM_ID);
    config_account.set_data_from_slice(&user_data);

    let attacker_account =
        AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    // Instruction: update_fee_vulnerable(new_fee)
    let disc = ix_discriminator("update_fee_vulnerable");
    let mut ix_data = Vec::with_capacity(16);
    ix_data.extend_from_slice(&disc);
    ix_data.extend_from_slice(&9999u64.to_le_bytes()); // attacker's fee

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_data,
        vec![
            AccountMeta::new(fake_config, false),
            AccountMeta::new_readonly(attacker, true),
        ],
    );

    let accounts = vec![
        (fake_config, config_account),
        (attacker, attacker_account),
    ];

    // UserData masquerades as AdminConfig — type cosplay succeeds!
    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}

#[test]
fn secure_rejects_wrong_discriminator() {
    // -----------------------------------------------------------------------
    // SECURE: The secure instruction uses Account<AdminConfig>, which
    // auto-checks the 8-byte discriminator. UserData has a different
    // discriminator than AdminConfig, so Anchor rejects it immediately.
    //
    // Expected: FAILS — AccountDiscriminatorMismatch (error code 3002).
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "type_cosplay");

    let attacker = Pubkey::new_unique();
    let fake_config = Pubkey::new_unique();

    // Same UserData cosplay attempt
    let user_data = serialize_user_data(&attacker, 0);
    let mut config_account =
        AccountSharedData::new(5_000_000, user_data.len(), &PROGRAM_ID);
    config_account.set_data_from_slice(&user_data);

    let attacker_account =
        AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    // Instruction: update_fee_secure(new_fee)
    let disc = ix_discriminator("update_fee_secure");
    let mut ix_data = Vec::with_capacity(16);
    ix_data.extend_from_slice(&disc);
    ix_data.extend_from_slice(&9999u64.to_le_bytes());

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_data,
        vec![
            AccountMeta::new(fake_config, false),
            AccountMeta::new_readonly(attacker, true),
        ],
    );

    let accounts = vec![
        (fake_config, config_account),
        (attacker, attacker_account),
    ];

    // AccountDiscriminatorMismatch = error code 3002
    mollusk.process_and_validate_instruction(
        &ix,
        &accounts,
        &[Check::err(ProgramError::Custom(3002))],
    );
}

#[test]
fn secure_accepts_real_admin_config() {
    // -----------------------------------------------------------------------
    // SANITY: A properly-typed AdminConfig account passes discriminator
    // verification and the admin authorization check.
    //
    // Expected: SUCCEEDS — correct type + correct admin.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "type_cosplay");

    let admin = Pubkey::new_unique();
    let config_key = Pubkey::new_unique();

    // Create a real AdminConfig with correct discriminator
    let admin_data = serialize_admin_config(&admin, 100);
    let mut config_account =
        AccountSharedData::new(5_000_000, admin_data.len(), &PROGRAM_ID);
    config_account.set_data_from_slice(&admin_data);

    let admin_account =
        AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    // Instruction: update_fee_secure(new_fee)
    let disc = ix_discriminator("update_fee_secure");
    let mut ix_data = Vec::with_capacity(16);
    ix_data.extend_from_slice(&disc);
    ix_data.extend_from_slice(&500u64.to_le_bytes()); // new fee

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_data,
        vec![
            AccountMeta::new(config_key, false),
            AccountMeta::new_readonly(admin, true),
        ],
    );

    let accounts = vec![
        (config_key, config_account),
        (admin, admin_account),
    ];

    // Real AdminConfig with correct admin → succeeds
    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}
