/// # Pattern 2: Missing Owner Check — Mollusk Exploit Tests
///
/// Real-world reference: Wormhole Bridge ($326M, February 2022)
///
/// - Test 1: EXPLOIT — passes a FAKE treasury account owned by a different program.
///   The vulnerable instruction reads it and trusts the data.
/// - Test 2: SECURE — the same fake account is rejected because Anchor's
///   `Account<'info, T>` verifies owner == program_id.
/// - Test 3: SANITY — a legitimate treasury with correct owner is accepted.
use mollusk_svm::{result::Check, Mollusk};
use sha2::{Digest, Sha256};
use solana_sdk::{
    account::AccountSharedData,
    instruction::{AccountMeta, Instruction},
    program_error::ProgramError,
    pubkey::Pubkey,
};

const PROGRAM_ID: Pubkey = solana_sdk::pubkey!("8anCcUkKVms75R4HYTnkbM6YGzAra9WTmXhNEY5RSaNw");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn ix_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("global:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

fn account_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("account:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

/// Serialize a Treasury account:
///   [8-byte discriminator][32-byte authority][8-byte balance (LE)][1-byte is_active]
fn serialize_treasury(authority: &Pubkey, balance: u64, is_active: bool) -> Vec<u8> {
    let disc = account_discriminator("Treasury");
    let mut data = Vec::with_capacity(49);
    data.extend_from_slice(&disc);
    data.extend_from_slice(authority.as_ref());
    data.extend_from_slice(&balance.to_le_bytes());
    data.push(if is_active { 1 } else { 0 });
    data
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[test]
fn exploit_fake_account_accepted() {
    // -----------------------------------------------------------------------
    // EXPLOIT: Pass a fake treasury owned by a DIFFERENT program.
    //
    // The Wormhole attack worked exactly this way: the attacker created an
    // account with the right byte layout but owned by a different program.
    // The vulnerable instruction reads raw AccountInfo data without checking
    // who owns the account.
    //
    // Expected: Transaction SUCCEEDS — the fake data is trusted.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "missing_owner");

    let attacker = Pubkey::new_unique();
    let fake_treasury = Pubkey::new_unique();

    // Fake account: correct byte layout, but owned by system_program (not our program)
    let fake_data = serialize_treasury(&attacker, 999_999_999, true);
    let mut fake_account =
        AccountSharedData::new(1_000_000, fake_data.len(), &solana_sdk::system_program::ID);
    //                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //                                  WRONG OWNER — should be PROGRAM_ID, but it's system_program
    fake_account.set_data_from_slice(&fake_data);

    let attacker_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_discriminator("process_vulnerable"),
        vec![
            AccountMeta::new_readonly(fake_treasury, false), // fake treasury
            AccountMeta::new_readonly(attacker, true),        // attacker signs
        ],
    );

    let accounts = vec![
        (fake_treasury, fake_account),
        (attacker, attacker_account),
    ];

    // EXPLOIT: The program reads the fake data and trusts it.
    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}

#[test]
fn secure_rejects_fake_account() {
    // -----------------------------------------------------------------------
    // SECURE: Same fake account, but the secure instruction uses
    // `Account<'info, Treasury>` which verifies owner == program_id.
    //
    // Anchor checks: (1) owner is this program, (2) discriminator matches,
    // (3) data deserializes to Treasury. Any failure = rejected.
    //
    // Expected: Transaction FAILS — Anchor rejects the wrong owner.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "missing_owner");

    let attacker = Pubkey::new_unique();
    let fake_treasury = Pubkey::new_unique();

    // Same fake data as above, owned by system_program
    let fake_data = serialize_treasury(&attacker, 999_999_999, true);
    let mut fake_account =
        AccountSharedData::new(1_000_000, fake_data.len(), &solana_sdk::system_program::ID);
    fake_account.set_data_from_slice(&fake_data);

    let attacker_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_discriminator("process_secure"),
        vec![
            AccountMeta::new_readonly(fake_treasury, false),
            AccountMeta::new_readonly(attacker, true),
        ],
    );

    let accounts = vec![
        (fake_treasury, fake_account),
        (attacker, attacker_account),
    ];

    // Anchor error 3007 = AccountOwnedByWrongProgram
    // "The given account is owned by a different program than expected"
    mollusk.process_and_validate_instruction(
        &ix,
        &accounts,
        &[Check::err(ProgramError::Custom(3007))],
    );
}

#[test]
fn secure_accepts_real_treasury() {
    // -----------------------------------------------------------------------
    // SANITY: A real treasury owned by this program is accepted.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "missing_owner");

    let authority = Pubkey::new_unique();
    let treasury = Pubkey::new_unique();

    // Real account: correct layout AND owned by our program
    let real_data = serialize_treasury(&authority, 1_000_000, true);
    let mut treasury_account =
        AccountSharedData::new(2_000_000, real_data.len(), &PROGRAM_ID);
    //                                                       ^^^^^^^^^^
    //                                          CORRECT OWNER — our program
    treasury_account.set_data_from_slice(&real_data);

    let authority_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_discriminator("process_secure"),
        vec![
            AccountMeta::new_readonly(treasury, false),
            AccountMeta::new_readonly(authority, true),
        ],
    );

    let accounts = vec![
        (treasury, treasury_account),
        (authority, authority_account),
    ];

    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}
