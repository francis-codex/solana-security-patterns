/// # Pattern 3: Integer Overflow/Underflow — Mollusk Exploit Tests
///
/// Demonstrates how wrapping arithmetic lets attackers:
/// - Overflow supply to zero (infinite mint)
/// - Underflow balance to u64::MAX (bypass insufficient funds)
///
/// Tests prove checked_add/checked_sub catch both cases.
use mollusk_svm::{result::Check, Mollusk};
use sha2::{Digest, Sha256};
use solana_sdk::{
    account::AccountSharedData,
    instruction::{AccountMeta, Instruction},
    program_error::ProgramError,
    pubkey::Pubkey,
};

const PROGRAM_ID: Pubkey = solana_sdk::pubkey!("3w5jyYEgbsnHjFcTUH9xdyH3KfN2YRppPCFUkskyYSxA");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn ix_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("global:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

fn account_discriminator(name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(format!("account:{name}").as_bytes());
    let hash = hasher.finalize();
    let mut disc = [0u8; 8];
    disc.copy_from_slice(&hash[..8]);
    disc
}

/// Serialize a Ledger account:
///   [8-byte discriminator][32-byte authority][8-byte total_supply][8-byte user_balance]
fn serialize_ledger(authority: &Pubkey, total_supply: u64, user_balance: u64) -> Vec<u8> {
    let disc = account_discriminator("Ledger");
    let mut data = Vec::with_capacity(56);
    data.extend_from_slice(&disc);
    data.extend_from_slice(authority.as_ref());
    data.extend_from_slice(&total_supply.to_le_bytes());
    data.extend_from_slice(&user_balance.to_le_bytes());
    data
}

fn build_ix(name: &str, ledger: Pubkey, authority: Pubkey, amount: u64) -> Instruction {
    let disc = ix_discriminator(name);
    let mut data = Vec::with_capacity(16);
    data.extend_from_slice(&disc);
    data.extend_from_slice(&amount.to_le_bytes());

    Instruction::new_with_bytes(
        PROGRAM_ID,
        &data,
        vec![
            AccountMeta::new(ledger, false),
            AccountMeta::new_readonly(authority, true),
        ],
    )
}

fn setup_ledger(
    total_supply: u64,
    user_balance: u64,
) -> (Pubkey, Pubkey, Vec<(Pubkey, AccountSharedData)>) {
    let authority = Pubkey::new_unique();
    let ledger_key = Pubkey::new_unique();

    let ledger_data = serialize_ledger(&authority, total_supply, user_balance);
    let mut ledger_account =
        AccountSharedData::new(10_000_000, ledger_data.len(), &PROGRAM_ID);
    ledger_account.set_data_from_slice(&ledger_data);

    let authority_account = AccountSharedData::new(1_000_000, 0, &solana_sdk::system_program::ID);

    let accounts = vec![
        (ledger_key, ledger_account),
        (authority, authority_account),
    ];
    (ledger_key, authority, accounts)
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[test]
fn exploit_overflow_supply_wraps_to_zero() {
    // -----------------------------------------------------------------------
    // EXPLOIT: Mint with amount that overflows total_supply.
    //
    // supply = u64::MAX, mint_amount = 1
    // supply.wrapping_add(1) = 0 — supply resets to zero!
    //
    // Expected: SUCCEEDS — the wrapping arithmetic silently overflows.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "integer_overflow");

    let (ledger, authority, accounts) = setup_ledger(u64::MAX, 0);
    let ix = build_ix("mint_vulnerable", ledger, authority, 1);

    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}

#[test]
fn exploit_underflow_balance_wraps_to_max() {
    // -----------------------------------------------------------------------
    // EXPLOIT: Burn more than the user's balance.
    //
    // user_balance = 10, burn_amount = 11
    // balance.wrapping_sub(11) = u64::MAX - 0 = 18446744073709551615
    //
    // The attacker now has u64::MAX tokens.
    //
    // Expected: SUCCEEDS — wrapping underflow creates tokens from nothing.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "integer_overflow");

    let (ledger, authority, accounts) = setup_ledger(1000, 10);
    let ix = build_ix("burn_vulnerable", ledger, authority, 11);

    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}

#[test]
fn secure_blocks_overflow() {
    // -----------------------------------------------------------------------
    // SECURE: checked_add catches the overflow.
    //
    // supply = u64::MAX, mint_amount = 1
    // checked_add(1) = None → ArithmeticOverflow error
    //
    // Expected: FAILS with custom error.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "integer_overflow");

    let (ledger, authority, accounts) = setup_ledger(u64::MAX, 0);
    let ix = build_ix("mint_secure", ledger, authority, 1);

    // Anchor custom error: ArithmeticOverflow = 6000 (first #[error_code] variant)
    mollusk.process_and_validate_instruction(
        &ix,
        &accounts,
        &[Check::err(ProgramError::Custom(6000))],
    );
}

#[test]
fn secure_blocks_underflow() {
    // -----------------------------------------------------------------------
    // SECURE: checked_sub catches the underflow.
    //
    // user_balance = 10, burn_amount = 11
    // checked_sub(11) = None → ArithmeticUnderflow error
    //
    // Expected: FAILS with custom error.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "integer_overflow");

    let (ledger, authority, accounts) = setup_ledger(1000, 10);
    let ix = build_ix("burn_secure", ledger, authority, 11);

    // Anchor custom error: ArithmeticUnderflow = 6001 (second #[error_code] variant)
    mollusk.process_and_validate_instruction(
        &ix,
        &accounts,
        &[Check::err(ProgramError::Custom(6001))],
    );
}

#[test]
fn secure_allows_valid_mint() {
    // -----------------------------------------------------------------------
    // SANITY: Normal mint within bounds succeeds.
    // -----------------------------------------------------------------------
    let mollusk = Mollusk::new(&PROGRAM_ID, "integer_overflow");

    let (ledger, authority, accounts) = setup_ledger(1000, 500);
    let ix = build_ix("mint_secure", ledger, authority, 100);

    mollusk.process_and_validate_instruction(&ix, &accounts, &[Check::success()]);
}
